# 数据结构
在学习算法之前，应当对链表、栈、队列、树、图等数据结构有一些了解，这些是基础，其次，还需要掌握一门编程语言。
算法中很多经典例子都使用了数据结构的特性。
1. 数据结构的底层存储方式只有两种：数组（顺序存储）和链表（链式存储）。二者有不同的特性和优缺点；
2. 数据结构的基本操作：增、删、查、改；
3. 链表具备最基础的递归特性；
总之，基础很关键。
**算法的学习曲线：先从链表、树开始，看一些简单、中等题，然后再学动态规划、回溯、贪心等概念框架。**


# 需要强调的是
- 很多算法不是仅有唯一解法，从暴力到寻找最优解是你成长的过程。
- 对于大众选手，切勿一上来就挑战高难度，这样反而丧失兴趣。
- 关键：技巧+思想；把握思想，摸清技巧，举一反三。
- 注意：为了方便调用，部分方法在写的时候前面加了static；为了便于将算法分类，类的命名方式多采用xxxSolution，例如DP问题集中在DPSolution*类中。


# 从leetcode的100热题中发现套路和框架思维
https://leetcode.cn/studyplan/top-100-liked/


# 排序算法（关于是否稳定在于，相同两个值在排序过程中是否改变前后位置）
- 稳定排序
- 不稳定排序


## 稳定排序
插入、冒泡、归并、基数

## 不稳定排序
选择、快速、希尔、堆


# 树的遍历

**前序遍历、中序遍历、后序遍历的区别在于：访问root节点的时机不同。**
- 前序（先序）：根左右
- 中序：左根右
- 后序：左右根

二叉树遍历框架如下：

```
void traverse(TreeNode root) {
  //前序遍历（也叫先序遍历）
  traverse(root.left);
  //中序遍历
  traverse(root.right);
  //后序遍历
}
```

- DFS（Depth First Search）
- BFS（Breath First Search）
- DFS/BFS在搜索引擎中的应用


**DFS和BFS是图论中两种非常重要的算法，生产上广泛用于拓扑排序，寻路（走迷宫），搜索引擎，爬虫等**

## DFS

深度优先遍历主要思路是从图中一个未访问的顶点 V 开始，沿着一条路一直走到底，然后从这条路尽头的节点回退到上一个节点，再从另一条路开始走到底...，不断递归重复此过程，直到所有的顶点都遍历完成，它的特点是不撞南墙不回头，先走完一条路，再换一条路继续走。

树是图的一种特例（连通无环的图就是树），实际上不管是前序遍历，还是中序遍历，亦或是后序遍历，都属于深度优先遍历。
因此树的DFS实现既可以用递归也可以用非递归（栈即先序遍历）

leetcode 104，111: 给定一个二叉树，找出其最大/最小深度。

## BFS

广度优先遍历，指的是从图的一个未遍历的节点出发，先遍历这个节点的相邻节点，再依次遍历每个相邻节点的相邻节点
树的BFS可以用非递归实现（队列）

## DFS/BFS在搜索引擎中的应用

我们几乎每天都在 Google, Baidu 这些搜索引擎，那大家知道这些搜索引擎是怎么工作的吗，简单来说有三步

1、网页抓取
搜索引擎通过爬虫将网页爬取，获得页面 HTML 代码存入数据库中

2、预处理
索引程序对抓取来的页面数据进行文字提取，中文分词，（倒排）索引等处理，以备排名程序使用

3、排名
用户输入关键词后，排名程序调用索引数据库数据，计算相关性，然后按一定格式生成搜索结果页面。

我们重点看下第一步，网页抓取。
这一步的大致操作如下：给爬虫分配一组起始的网页，我们知道网页里其实也包含了很多超链接，爬虫爬取一个网页后，解析提取出这个网页里的所有超链接，再依次爬取出这些超链接，再提取网页超链接。。。，如此不断重复就能不断根据超链接提取网页。如下图示

如上所示，最终构成了一张图，于是问题就转化为了如何遍历这张图，显然可以用深度优先或广度优先的方式来遍历。
如果是广度优先遍历，先依次爬取第一层的起始网页，再依次爬取每个网页里的超链接，如果是深度优先遍历，先爬取起始网页 1，再爬取此网页里的链接...，爬取完之后，再爬取起始网页 2...
实际上爬虫是深度优先与广度优先两种策略一起用的，比如在起始网页里，有些网页比较重要（权重较高），那就先对这个网页做深度优先遍历，遍历完之后再对其他（权重一样的）起始网页做广度优先遍历。


# 动态规划 DP（Dynamic Programming）
- "最大、最小、最长、多少种方法" 这些字眼
- 关键是找到初始状态和状态转移方程（类似数学归纳）


# 贪心算法（Greedy Algorithm）
可看作动态规划的特例，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。
该算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。
贪心算法通常用来解决一些最优化问题，比如找零钱、背包问题等。
- 推导举反例
- 局部最优 -> 整体最优

# 回溯算法（BackTrack Algorithm）
回溯可以通俗理解为做选择时，先选择再撤销。
常在求子集（subset）、排列（permutation）、组合（combination）问题中使用；很多时候，组合就是固定长度的子集。

